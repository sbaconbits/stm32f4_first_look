// Copyright (c) 2016 Steven Bacon
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
// File Name: dac_dma.c
//

#include <math.h>

#include "stm32f4xx.h"
#include "util_macros.h"
#include "stm32f4_regs.h"
#include "errata.h"

#include "usart_basic.h"

#define PERPH_BURST_SIZE 4
#define PERPH_DATA_SIZE  4
#define DMA_TRANSFER_SIZE (100 * PERPH_BURST_SIZE * PERPH_DATA_SIZE)

// Note:
// DAC DMA requests generated by timer 6.

static volatile uint16_t dma_transfer_buffer[DMA_TRANSFER_SIZE];

static volatile uint32_t dma_int_count = 0;
void DMA1_Stream5_IRQHandler(void)
{
    //TODO be specific
    // Clear interrupts
    DMA1->LIFCR = 0xffffffff;
    DMA1->HIFCR = 0xffffffff;

    ++dma_int_count;
}

static void init_data_triangle_wave(void)
{
    uint16_t val;
    int i, pos=0;

    for(i=0; i<DMA_TRANSFER_SIZE/2; i++)
    {
        val = (i * DAC_DHR12R1_MASK) / (DMA_TRANSFER_SIZE/2);
        dma_transfer_buffer[pos] = val & DAC_DHR12R1_MASK;
        pos++;
    }

    for(i=0; i<DMA_TRANSFER_SIZE/2; i++)
    {
        //val = DAC_DHR12R1_MASK - (i * DAC_DHR12R1_MASK) / (DMA_TRANSFER_SIZE/2);
        val = DAC_DHR12R1_MASK - dma_transfer_buffer[i];
        dma_transfer_buffer[pos] = val & DAC_DHR12R1_MASK;
        pos++;
    }
}

static void init_data_sine_wave(void)
{
    int i;
    int sine_peak = 1024;    // 1/2 scale peak
    double val, rad=0;

    //TODO why is there loads of clipping without the offsets, is it the DAC reference?

    for(i=0; i<DMA_TRANSFER_SIZE; i++)
    {
        rad = i * (2 * M_PI) / DMA_TRANSFER_SIZE;
        val = sin(rad) * sine_peak;
        dma_transfer_buffer[i] = (uint16_t)(val + sine_peak + sine_peak/2); //+ offset due to clipping at the bottom
    }
}




void dac_dma_init(void)
{
    // Initialise the transfer data.
    //init_data_triangle_wave();
    init_data_sine_wave();

    // Configure PA5 and PA4 to analog (AIN) to avoid parasitic power consumption.
    SET_BITS_AFTER_CLR(GPIOA->MODER, GPIO_MODER_MASK, GPIO_MODER_VAL_ANA, (5 * GPIO_MODER_BITS));
    SET_BITS_AFTER_CLR(GPIOA->MODER, GPIO_MODER_MASK, GPIO_MODER_VAL_ANA, (4 * GPIO_MODER_BITS));
    // Peripheral clock enable for GPIO A (AHB)
    // Port A clock enable
    SET_BITS(RCC->AHB1ENR, RCC_AHB1ENR_GPIOAEN_VAL_ENABLE, RCC_AHB1ENR_GPIOAEN_SHIFT);
    // DMA1 clock enable
    SET_BITS(RCC->AHB1ENR, RCC_AHB1ENR_DMA1EN_VAL_ENABLE, RCC_AHB1ENR_DMA1EN_SHIFT);
    // Peripheral clock enable for DAC  (APB)
    SET_BITS(RCC->APB1ENR, RCC_APB1ENR_DACEN_VAL_ENABLE, RCC_APB1ENR_DACEN_SHIFT);
    // Peripheral clock enable for TIM6
    SET_BITS(RCC->APB1ENR, RCC_APB1ENR_TIM6_VAL_ENABLE, RCC_APB1ENR_TIM6_SHIFT);
    ERRATA_2_1_13;
    // DAC Channel 1 trigger enable.
    SET_BITS(DAC->CR, DAC_CR_TEN1_VAL_ENABLE, DAC_CR_TEN1_SHIFT);
    // DAC trigger selection channel 1 used timer6
    SET_BITS(DAC->CR, DAC_CR_TSEL1_VAL_TIMER6, DAC_CR_TSEL1_SHIFT);

    // DMA setup:
    // DMA1 stream 5 peripheral address register set to DAC channel1 12-bit right-aligned data.
    DMA1_Stream5->PAR = (uint32_t)&(DAC->DHR12R1);
    // DMA stream 5 memory 0 address register
    DMA1_Stream5->M0AR = (uint32_t)dma_transfer_buffer;
    // DMA stream 5 number of data items to transfer
    DMA1_Stream5->NDTR = (DMA_TRANSFER_SIZE & DMA_SxNDTR_NDT_MASK) << DMA_SxNDTR_NDT_SHIFT;
    // Request mapping: DMA1, Channel 7, Stream 5 is for DAC1
    SET_BITS(DMA1_Stream5->CR, (DMA_SxCR_CHSEL_MASK & 7), DMA_SxCR_CHSEL_SHIFT);
    // Circular mode
    SET_BITS(DMA1_Stream5->CR, DMA_SxCR_CIRC_VAL_ENABLE, DMA_SxCR_CIRC_SHIFT);
    // Set the memory data size to 16-bit
    SET_BITS(DMA1_Stream5->CR, DMA_SxCR_MSIZE_VAL_16BIT, DMA_SxCR_MSIZE_SHIFT);
    // Set the peripheral data size to 16-bit
    SET_BITS(DMA1_Stream5->CR, DMA_SxCR_PSIZE_VAL_16BIT, DMA_SxCR_PSIZE_SHIFT);
    // Memory address pointer incremented by MSIZE after each transfer.
    SET_BITS(DMA1_Stream5->CR, DMA_SxCR_MINC_VAL_BY_MSIZE, DMA_SxCR_MINC_SHIFT);
    // Data transfer direction is from memory to peripheral
    SET_BITS(DMA1_Stream5->CR, DMA_SxCR_DIR_VAL_MEM_TO_PERPH, DMA_SxCR_DIR_SHIFT);
    // Enable transfer complete interrupt
    SET_BITS(DMA1_Stream5->CR, DMA_SxCR_TCIE_VAL_ENABLE, DMA_SxCR_TCIE_SHIFT);

    // NOTE: !! Do this last !!
    // Enable this DMA channel
    SET_BITS(DMA1_Stream5->CR, DMA_SxCR_EN_VAL_ENABLE, DMA_SxCR_EN_SHIFT);
    // DAC channel 1 DMA enable
    SET_BITS(DAC->CR, DAC_CR_DMAEN1_VAL_ENABLE, DAC_CR_DMAEN1_SHIFT);
    // Enable channel 1 on DAC
    SET_BITS(DAC->CR, DAC_CR_EN1_VAL_ENABLE, DAC_CR_EN1_SHIFT);

    // Setup timer 6 as a trigger event for the DAC to request a DMA transfer.
    // Update DMA request enabled
    SET_BITS(TIM6->DIER, TIM6_DIER_UDE_VAL_ENABLE, TIM6_DIER_UDE_SHIFT);
    // Set the prescaler value
    TIM6->PSC = 0;
    // Auto-reload value
    TIM6->ARR = 1;
    // Trigger output (TRGO) on update.
    SET_BITS(TIM6->CR2, TIM6_CR2_MMS_VAL_UPDATE, TIM6_CR2_MMS_SHIFT);
    // Counter enable
    SET_BITS(TIM6->CR1, TIM6_CR1_CEN_VAL_ENABLE, TIM6_CR1_CEN_SHIFT);

    // Enable all of the interrupts that we want to see
    // DMA1_Stream5_IRQn(16)
    NVIC->ISER[DMA1_Stream5_IRQn/32] |= (1 << (DMA1_Stream5_IRQn & 0x1f));
}

void dac_dma_repeat(void)
{
    // Nothing to do here, in circular mode the above should go on forever

    print_string("dac_dma_repeat ");

    print_string(" dma_int_count:");
    print_hex_32(dma_int_count);

    print_string("\r\n");
}

